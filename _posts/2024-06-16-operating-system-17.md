---
title: "[OS] Virtual Memory"
excerpt: "Operating Systems, Internals and Design Principles 정리"

categories:
  - CS
tags:
  - [Operating System]

permalink: /cs/operating_system17/

toc: true
toc_sticky: true
use_math: true

date: 2024-06-16
last_modified_at: 2025-05-05
published: true
---

> William Stallings의 『Operating Systems, Internals and Design Principles (9th Ed.)』 을 토대로 작성하였음. <br>

<br>

# 👑 Virtual Memory

`paging`과 `segmentation` 기법에서 한 프로세스는 여러 블록으로 분할될 수 있으며, 분할된 블록들은 <br>

메인 메모리의 연속된 영역에 위치할 필요가 없었다. 또한, 프로세스 수행 시간에 프로세스의 논리주소는 <br>

동적으로 물리주소로 변환된다. 이는 프로세스가 `swap`을 통해 다시 메모리에 로드될 때, 이전과 다른 <br>

위치에 로드될 수 있음을 의미한다. `(relocation)` <br><br>

위의 두 특성들을 만족한다면, 프로세스의 수행 시간 동안에 `프로세스의 모든 블록들이 메인 메모리에` <br>

`로드되어 있을 필요가 없다.` 프로세스의 일부 블록만을 메인 메모리에 적재시키는 방법을 사용함으로써 <br>

다음의 장점들을 가질 수 있다.

<br>

**더 많은 프로세스를 메인 메모리에 유지할 수 있다.**

- 프로세스의 일부 블록들만 로드하기 때문에 보다 많은 프로세스를 가지고 있을 수 있다.

- 이로 인해 임의의 시점에 `ready` 상태의 프로세스가 메인 메모리에 존재할 가능성이 더 커지므로 <br>
  시스템의 효율성이 증가한다. (throughput ↑)

**메인 메모리보다 큰 프로세스를 수행할 수 있다.**

- 프로그램의 실행은 메인 메모리에 로드되어야만 가능하며, 메인 메모리의 용량은 한정되어 있다.

- 따라서, 위의 기법을 적용하지 않을 경우, 사용자는 메인 메모리 용량보다 큰 프로그램을 실행시키지 <br>
  못할 것이다.

- 가상메모리는 효과적인 멀티 프로그래밍을 허용하며, 메인 메모리의 엄격한 제약을 해소시켜 준다.

<br>

위 기법을 사용하여 사용자는 보조기억장치를 활용하여 메인 메모리보다 훨씬 큰 메모리를 가질 수 있게 <br>

되었다. 즉, 실제 주기억장치 용량보다 훨씬 큰 메모리를 사용하는 것처럼 느낄 수 있게 하며, 이를 <br>

`가상 메모리 (Virtual Memory)`라 부른다.

<br>

## 💡 가상 메모리와 프로그램의 실행

가상 메모리를 통한 프로그램의 실행 과정은 다음과 같다.

- **OS가 프로세스의 일부 블록만을 메인 메모리에 로드시킨다.**

  + 프로세스의 코드나 데이터 중 임의의 시점에 메인 메모리에 로드되어 있는 부분을 <br>
    `resident set`이라 한다.

- **메인 메모리에 없는 논리주소가 참조될 경우 인터럽트가 발생한다.**

  + 프로세스가 `resident set`에 포함된 주소를 참조하는 동안은 수행이 잘 이루어지지만, <br>
    그렇지 않은 주소를 참조할 경우 `page fault` 인터럽트를 발생시킨다.

- **OS가 인터럽트 당한 프로세스를 block 상태로 둔다.**

  + 이후 프로세스의 수행을 재개하기 위해서는 해당 논리주소를 포함한 프로세스의 블록을 <br>
    메인 메모리로 로드해야 하며, 이를 위해 `Disk I/O request`가 필요하다.

- **Disk I/O가 진행되는 동안 다른 프로세스에게 CPU를 넘겨 수행될 수 있게 한다.**

  + 디스크 입출력이 끝나면 입출력 인터럽트가 발생하게 되고, `OS`가 제어를 돌려받으며, <br>
    `block` 되었던 프로세스를 `ready` 상태로 전환시킨다.

<br>

## 💡 지역성 (Locality)

가상 메모리를 사용하여 얻을 수 있는 장점들은 확실하지만, 이 방법이 실용적인가에 대한 논의 역시 <br>

이뤄져 왔다. 메인 메모리에 적재되지 않은 블록들로 인해 반복적인 인터럽트가 발생하는 것이 명백하고, <br>

이 점을 통해 효율성에 대한 의구심이 생길 수 있다. 하지만, 가상 메모리를 사용한 운영체제가 주는 <br>

이점으로 인해 이 의구심은 해소될 수 있다. <br><br>

가상 메모리 방식에서 각 프로세스는 메모리 상에 몇 개의 블록만을 가지게 되며, 이를 통해 더 많은 <br>

프로세스를 메모리에 유지할 수 있다. 또한 불필요한 블록들에 대한 반입/반출을 수행하지 않기에 시간을 <br>

절약할 수 있다. <br><br>

물론 `OS`는 블록 관리를 지능적으로 수행해야만 한다. `안정 상태 (safe state)`에서는 가능한 한 많은 <br>

프로세스 블록들이 메인 메모리 전체를 채우고 있다. 따라서 다른 블록을 반입하기 위해서는 블록 하나를 <br>

반출해야만 한다. 만약 특정 블록이 사용되기 직전에 반출된다면, 그 블록은 곧바로 반입되게 될 것이다. <br>

이와 같은 상황이 과도하게 발생되면, `쓰레싱(Thrashing)`에 이르게 되어, 시스템이 블록 교체에 대부분의 <br>

시간을 허비하게 될 것이다. <br><br>

이런 문제를 처리하기 위해 다양한 알고리즘들이 제시되었으며, 운영체제는 근본적으로 최근의 참조 이력을 <br>

근거로 가까운 미래에 사용될 가능성이 가장 적은 블록을 추정하는데, 이러한 추론은 `지역성의 원리` <br>

`(Principle of Locality)`에 근거한다. 지역성의 원리란 프로세스에 대한 참조가 군집화 경향이 있음을 <br>

의미한다. 즉, 짧은 시간 동안 단지 프로세스의 블록 몇 개만이 필요할 것이며, 가까운 미래에 어떤 블록이 <br>

필요할 것인가에 대한 예측을 통해 쓰레싱을 피하고, 효율적으로 메모리를 관리할 수 있게 한다.
 