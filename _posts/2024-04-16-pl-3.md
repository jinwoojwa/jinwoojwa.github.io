---
title: "[PL] OCaml Basic2"
excerpt: "í”„ë¡œê·¸ë˜ë°ì–¸ì–´ê°œë¡ "

categories:
  - í”„ë¡œê·¸ë˜ë°ì–¸ì–´ë¡ 
tags:
  - [Programming Language]

permalink: /programming-language/pl-ocaml-basic2/

toc: true
toc_sticky: true

date: 2024-04-16
last_modified_at: 2024-04-16
published: true
---

# ğŸ‘‘ OCaml Basic 2

<br>

## ğŸ’¡ Module ì´ë€?

> OCamlì—ì„œì˜ module : ìë£Œë“¤ì˜ ì§‘í•© (= ê°ì²´í™”ê°€ ë¶ˆê°€ëŠ¥í•œ í´ë˜ìŠ¤)

OCamlì€ `Module system`ì„ ì§€ì›í•œë‹¤. í”„ë¡œê·¸ë¨ì€ ì—¬ëŸ¬ê°œì˜ ëª¨ë“ˆë¡œ êµ¬ì„±ë˜ì–´ ìˆìœ¼ë©°, ê°ê°ì˜ ëª¨ë“ˆì€ ìë£Œ(ë³€ìˆ˜)ì™€ í–‰ë™(í•¨ìˆ˜)ìœ¼ë¡œ êµ¬ì„±ëœë‹¤. <br>

ëª¨ë“ˆì€ ê·¸ ìì²´ë¡œ íƒ€ì…ì€ ì•„ë‹ˆë©°, ê°ì²´í™”ê°€ ë¶ˆê°€ëŠ¥í•˜ì—¬ ëª¨ë“ˆì˜ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ê±°ë‚˜ ìë£Œë¥¼ ì½ëŠ” í–‰ìœ„ë§Œ ê°€ëŠ¥í•˜ë‹¤. <br>

ëª¨ë“  ì†ŒìŠ¤íŒŒì¼ì€ `ê·¸ ìì²´ë¡œ ëª¨ë“ˆ`ì´ë‹¤. <br>

ëª¨ë“ˆì— ì ‘ê·¼í•  ë•Œ, ëª¨ë“ˆ ì´ë¦„ì˜ ì²« ê¸€ìë¥¼ `ëŒ€ë¬¸ì`ë¡œ í•´ì•¼í•œë‹¤.

- e.g. module1.ml ì˜ numì— ì ‘ê·¼ : `M`odule1.num

```ml
(* module1.ml *)
let num = 10
let mul x y = x * y

(* module2.ml *)
let _ = Format.printf "Result : %d\n" Module1.num
let _ = Format.printf "Result : %d\n" (Module1.mul 2 4)
```

<br>

- ëª¨ë“ˆ ë‚´ì— ëª¨ë“ˆì„ ì •ì˜í•  ìˆ˜ ìˆë‹¤. (`Nested module`) <br><br>

    + C++ or Javaì˜ `inner class` ì™€ ìœ ì‚¬í•˜ë‹¤.
    
    + `module [module_name] = struct [defs] end` ë¥¼ í†µí•´ ìƒì„± ê°€ëŠ¥í•˜ë‹¤. <br>
        - â— `module_name` ì€ ë°˜ë“œì‹œ ëŒ€ë¬¸ìë¡œ ì‹œì‘í•´ì•¼ í•œë‹¤.

    ```ml
    (* module1.ml *)
    module IntAdd = struct
      let add x y = x + y
    end

    module FloatAdd = struct
      let add x y = x + y
    end

    (* module2.ml *)
    let _ = Format.printf "Result : %d\n" (Module1.IntAdd.add 2 4)
    let _ = Format.printf "Result : %d\n" (Module2.FloatAdd.add 2.0 4.0)
    ```

<br>

- ëª¨ë“ˆì„ `open` í•˜ì—¬ ëª¨ë“ˆ ì ‘ê·¼ ì‹œì— ëª¨ë“ˆ ì´ë¦„ì„ ìƒëµí•  ìˆ˜ ìˆë‹¤. <br><br>

    + `open [module_name]` : í˜„ì¬ `scope` ë‚´ì—ì„œ ëª¨ë“ˆ ë‚´ ë³€ìˆ˜ë¥¼ ëª¨ë“ˆ ì´ë¦„ ì—†ì´ ì ‘ê·¼ ê°€ëŠ¥ <br>

    + C++ ì˜ `namespace` ì™€ ìœ ì‚¬í•˜ë‹¤.

    + ë‹¤ë¥¸ ì—¬ëŸ¬ ëª¨ë“ˆë“¤ì— ê°™ì€ ì´ë¦„ì´ ìˆì„ ê²½ìš° `comflict`ê°€ ë°œìƒ ê°€ëŠ¥í•¨ì— ìœ ì˜í•´ì•¼ í•œë‹¤.

    ```ml
    (* module2.ml *)
    open Module1

    let _ = Format.printf "Result : %d\n" (IntAdd.add 2 4)
    let _ = Format.printf "Result : %d\n" (FloatAdd.add 2.0 4.0)
    ```

    + íŠ¹ì • `scope` ë‚´ì—ì„œë§Œ ëª¨ë“ˆì„ ê°œë°©í•  ìˆ˜ë„ ìˆë‹¤.

    ```ml
    let _ =
      let open Module1.IntAdd in
      let _ = Format.printf "Result : %d\n" (add 2 4) in
      let _ = Format.printf "Result : %d\n" (add 1 2) in
      Format.printf "Result : %d\n" (add 4 5)
    ```

<br>

- ëª¨ë“ˆ ì´ë¦„ì´ ê¸´ ê²½ìš°, `renaming` ì´ ê°€ëŠ¥í•˜ë‹¤. <br><br>

    + `module [abbreviation] = [module_name]`

    ```ml
    (* module2.ml *)
    module M1I = Module1.IntAdd
    module M1F = Module1.FloatAdd
    module F = Format

    begin
      F.printf "Result : %d\n" (M1I,add 3 7);
      F.printf "Result : %d\n" (M1F.add 2.0 3.0)
    end
    ```

<br>

## ğŸ’¡ Pattern Matching

OCamlì€ C++, Java ì˜ `switch-case`ì™€ ìœ ì‚¬í•œ `match-with expression`ì„ ì œê³µí•œë‹¤. <br>

ê°’ì˜ "í˜•íƒœ"ì— ë”°ë¼ ë‹¤ë¥´ê²Œ ì²˜ë¦¬í•´ì•¼ í•˜ëŠ” ê²½ìš°ì— ìœ ìš©í•˜ê²Œ ì‚¬ìš©ëœë‹¤. <br>

- ë§¤ì¹­ë˜ëŠ” ê²½ìš°ì— í•´ë‹¹ expressionì„ ê³„ì‚°í•˜ê³ , ê·¸ ê²°ê³¼ê°€ ì „ì²´ì˜ ê²°ê³¼ì´ë‹¤.

- `pattern`ì€ `constant`ì™€ `variable`ë¡œ êµ¬ì„±ëœë‹¤. <br><br>

  + ìƒìˆ˜ì¸ ê²½ìš° : ê³„ì‚° ê°’ì´ íŒ¨í„´ê³¼ ì¼ì¹˜í•˜ëŠ” ì§€ë¥¼ ë§¤ì¹­

  + ë³€ìˆ˜ì¸ ê²½ìš° : ê³„ì‚° ê°’ì„ ë³€ìˆ˜ì— `binding` (**í•­ìƒ ë§¤ì¹­ì— ì„±ê³µ**)

    * ì¦‰, ë³€ìˆ˜ê°€ ì• íŒ¨í„´ì— ë“±ì¥ -> ì´í›„ì˜ íŒ¨í„´ì€ ë§¤ì¹­ë˜ì§€ ì•ŠëŠ”ë‹¤.

```ml
match expression with         (* 1. expression ê³„ì‚° *)
| pattern1 -> expression1     (* 2. ê³„ì‚° ê²°ê³¼ë¥¼ pattern1ê³¼ ë§¤ì¹­ *)
| pattern2 -> expression2     (* 3. ë§¤ì¹­ ì‹¤íŒ¨ ì‹œ pattern2ì™€ ë§¤ì¹­ *)
.
.
.
| patternN -> expressionN     (* ... *)

let _ =
  let check_value x =
    match x with
    | 0 -> 0
    | y -> y
    | 1 -> 1
  in
  Format.printf "Result : %d\n" (check_value 2)

-> warning ë°œìƒ [redundant-case]: this match case is unused.
```
<br>

- patternì— wildcard `_` ì‚¬ìš© ê°€ëŠ¥ <br><br>

  + í•­ìƒ ë§¤ì¹­ì— ì„±ê³µí•œë‹¤.

  + ê°’ì´ `binding` ë˜ì§€ X -> ë§¤ì¹­ëœ ê°’ ì‚¬ìš© ì•ˆí•¨

  + ë§Œì•½ ì•„ë˜ì˜ ì½”ë“œì—ì„œ `wildcard` íŒ¨í„´ì´ ë¹ ì§„ë‹¤ë©´ -> warning

    * `i mod 2`ì˜ ê²°ê³¼ëŠ” í•­ìƒ 0 or 1 ì´ì§€ë§Œ, ì½”ë“œì— í¬í•¨ë˜ì–´ì•¼ í•œë‹¤!

  + OCaml ì»´íŒŒì¼ëŸ¬ëŠ” `expressionì˜ íƒ€ì…`ì„ ê¸°ë°˜ìœ¼ë¡œ íŒ¨í„´ë§¤ì¹­ì˜ ì™„ì „ì„±ì„ ê²€ì‚¬í•œë‹¤.

    * ì˜ˆë¥¼ ë“¤ì–´, expressionì´ int íƒ€ì…ì¸ ê²½ìš° -> ëª¨ë“  int ê°’ì„ ì»¤ë²„í•  ìˆ˜ ìˆì–´ì•¼ í•¨.

```ml
let _ = 
  let even_or_odd i =
    match i mod 2 with
    | 0 -> Format.printf "Even\n"
    | 1 -> Format.printf "Odd\n"
    | _ -> Format.printf "Unknown\n"
  in
  let _ = even_or_odd 0 in (* Even *)
  let _ = even_or_odd 1 in (* Odd *)
  even_or_odd 3 (* Odd *)
```

<br>

- `..` ê¸°í˜¸ë¥¼ ì‚¬ìš©í•˜ì—¬ ì—°ì†ëœ ë¬¸ì í˜¹ì€ ìˆ«ìì— ëŒ€í•œ íŒ¨í„´ ìƒì„± ê°€ëŠ¥

```ml
let _ =
  let check_lower c =
    match c with
    | 'a' .. 'z' -> true  (* 'a' ë¶€í„° 'z' ê¹Œì§€ *)
    | _ -> false
  in
  let _ = Format.printf "c : %b\n" (check_lower 'c') in   (* true *)
  Format.printf "C : %b\n" (check_lower 'C')              (* false *)
```

<br>

- `match-with expression`ë„ ì´ ìì²´ë¡œ `expression` ì´ê¸°ì— í•˜ë‚˜ì˜ íƒ€ì…ë§Œì„ ê°€ì ¸ì•¼ í•œë‹¤. <br><br>

  + ê° match caseì˜ expressionì´ ëª¨ë‘ ë™ì¼í•œ íƒ€ì…ì„ ê°€ì ¸ì•¼ë§Œ í•œë‹¤.

```ml
let _ =
  let check_lower c =
    match c with
    | 'a' .. 'z' -> true  (* 'a' ë¶€í„° 'z' ê¹Œì§€ *)
    | _ -> 0
  in
  ...   (* ê°ê°ì˜ expressionì´ bool, int íƒ€ì…ìœ¼ë¡œ ì„œë¡œ ë‹¤ë¥´ê¸° ë•Œë¬¸ì— ì—ëŸ¬ ë°œìƒ *)
```

<br>

- `tuple` ë“±ì˜ ìë£Œêµ¬ì¡°ì— ëŒ€í•´ì„œë„ íŒ¨í„´ ë§¤ì¹­ì´ ê°€ëŠ¥í•˜ë‹¤. <br>

```ml
let _ =
  let get_first t =
    match t with
    | (first, _) -> first
  in
  let get_second t =
    match t with
    | (_, second) -> second
  in
  let _ = Format.printf "first : %d\n" (get_first (2, 5)) in (* 2 *)
  Format.printf "second : %d\n" (get_second (3, 4))          (* 4 *)
```

<br>

## ğŸ’¡ List

ì„œë¡œ ë‹¤ë¥¸ íƒ€ì…ì˜ ì›ì†Œë¥¼ ê°€ì§ˆ ìˆ˜ ìˆëŠ” `íŠœí”Œ`ê³¼ëŠ” ë‹¤ë¥´ê²Œ, <br>

ë¦¬ìŠ¤íŠ¸ì˜ ëª¨ë“  ì›ì†ŒëŠ” ë™ì¼í•œ íƒ€ì…ì„ ê°€ì ¸ì•¼ë§Œ í•œë‹¤. <br>

- OCaml ì—ì„œ ë¦¬ìŠ¤íŠ¸ì˜ ìƒì„±ì€ `[]`ë¥¼ ì‚¬ìš©í•˜ê³ , ì›ì†Œë¼ë¦¬ì˜ êµ¬ë¶„ì€ `;`ì„ ì´ìš©í•œë‹¤. <br>

```ml
[1; 2; 3; 4], ['a'; 'b'; 'c'], ["Hello"; "World"]
```

<br>

- **ë¦¬ìŠ¤íŠ¸ ì—°ì‚°ì**

  + `::` ì—°ì‚°ì : ë¦¬ìŠ¤íŠ¸ `ì•ì— ì›ì†Œë¥¼ ì‚½ì…`í•˜ì—¬ `ìƒˆë¡œìš´ ë¦¬ìŠ¤íŠ¸ë¥¼` ë°˜í™˜

  ```ml
  let lst = 0 :: [1; 2; 3]  (* [0; 1; 2; 3] *)
  ```

  <br>

  + `@` ì—°ì‚°ì : `ë‘ ê°œì˜ ë¦¬ìŠ¤íŠ¸ë¥¼ ì—°ê²°`í•˜ì—¬ `ìƒˆë¡œìš´ ë¦¬ìŠ¤íŠ¸ë¥¼` ë°˜í™˜

  ```ml
  let lst = [1; 2] @ [3; 4]  (* [1; 2; 3; 4] *)
  ```

<br>

- **[OCaml List Library](https://ocaml.org/manual/5.1/api/List.html)**

  + OCamlì€ Listì— ëŒ€í•œ ë‚´ì¥ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì œê³µí•œë‹¤. <br>

  + ì£¼ìš” í•¨ìˆ˜

    > `'a` ëŠ” ì„ì˜ì˜ íƒ€ì…ì„ ê°€ë¦¬í‚´

    <br>

    * `List.iter : ('a -> unit) -> 'a list -> unit`

      ğŸ”¹ `í•¨ìˆ˜`ì™€ `ë¦¬ìŠ¤íŠ¸`ë¥¼ ì¸ìë¡œ ë°›ì•„, ê° ë¦¬ìŠ¤íŠ¸ì˜ ì›ì†Œì— í•¨ìˆ˜ë¥¼ apply <br>
      ğŸ”¹ ë°˜í™˜ê°’ì´ `unit` = ë°˜í™˜ê°’ ì—†ìŒ <br>

    ```ml
    let print_square x = Format.printf "%d " (x * x)

    let lst = [1; 2; 3; 4] in
    List.iter print_square lst

    (* ì¶œë ¥ : 1 4 9 16 *)
    ```

    <br>

    * `List.map : ('a -> 'b) -> 'a list -> 'b list`

      ğŸ”¹ `í•¨ìˆ˜`ì™€ `ë¦¬ìŠ¤íŠ¸`ë¥¼ ì¸ìë¡œ ë°›ì•„, ë¦¬ìŠ¤íŠ¸ì˜ ê° ì›ì†Œì— í•¨ìˆ˜ë¥¼ applyí•œ ìƒˆë¡œìš´ `ë¦¬ìŠ¤íŠ¸ë¥¼ ë°˜í™˜`í•˜ëŠ” í•¨ìˆ˜ <br>

    ```ml
    let _ =
      let lst = [1; 2; 3] in
      let new_lst = List.map (fun x -> x + 1) lst
      ...

      (* new_lst = [2; 3; 4] *)
    ```

    <br>

    * `List.fold_left : ('acc -> 'a -> 'acc) -> 'acc -> 'a list -> 'acc`

      ğŸ”¹ `í•¨ìˆ˜`, `ì´ˆê¸°ê°’`, `ë¦¬ìŠ¤íŠ¸`ë¥¼ ì¸ìë¡œ ë°›ì•„, ë¦¬ìŠ¤íŠ¸ì˜ ì²« ì›ì†Œë¶€í„° í•¨ìˆ˜ë¥¼ ì ìš©í•˜ì—¬ ëˆ„ì  ê°’ì„ ê°±ì‹ í•˜ê³  `ìµœì¢… ëˆ„ì  ê°’`ì„ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜ <br>

    ```ml
    let sum acc x = acc + x

    let lst = [1; 2; 3; 4] in
    let result = List.fold_left sum 0 lst in
    Format.printf "Sum : %d\n" result

    (* Sum : 10 *)
    (* - ì²«ë²ˆì§¸ ì›ì†Œ 1ì— ëŒ€í•´ 0 (acc) + 1 -> acc = 1 *)
    (* - ë‘ë²ˆì§¸ ì›ì†Œ 2ì— ëŒ€í•´ 1 (acc) + 2 -> acc = 3 *)
    (* - ì„¸ë²ˆì§¸ ì›ì†Œ 3ì— ëŒ€í•´ 3 (acc) + 3 -> acc = 6 *)
    (* - ë„¤ë²ˆì§¸ ì›ì†Œ 4ì— ëŒ€í•´ 6 (acc) + 4 -> acc = 10 *)
    ```

<br>

- **Listì™€ Pattern matching**

```ml
let rec len lst = 
  match lst with
  | [] -> 0     (* listê°€ ë¹„ì–´ìˆì„ ê²½ìš° *)
  | _ :: t ->   (* listê°€ ê°’ì„ ê°€ì§ˆ ê²½ìš° *)
      1 + (len t)

(* -------------------- *)

let lst = [1; 2; 3; 4]

match lst with
| [] -> print_endline "Empty list"
| [x] -> print_endline "Single element list"
| x :: y :: rest -> print_endline "Two or More element list"

(*
[] íŒ¨í„´ : ë¦¬ìŠ¤íŠ¸ê°€ ë¹„ì–´ ìˆëŠ” ê²½ìš°
[x] íŒ¨í„´ : ë¦¬ìŠ¤íŠ¸ì— í•˜ë‚˜ì˜ ìš”ì†Œë§Œ ìˆëŠ” ê²½ìš°
x :: y :: rest íŒ¨í„´ : ë¦¬ìŠ¤íŠ¸ì— ì ì–´ë„ ë‘ ê°œì˜ ìš”ì†Œê°€ ìˆëŠ” ê²½ìš°

  'x'ëŠ” ì²« ë²ˆì§¸ ìš”ì†Œ, 'y'ëŠ” ë‘ ë²ˆì§¸ ìš”ì†Œ, restëŠ” ë¦¬ìŠ¤íŠ¸ì˜ ë‚˜ë¨¸ì§€ ìš”ì†Œë“¤
  ìœ„ì˜ lstì—ì„œ x = 1, y = 2, rest = [3; 4]
*)
```

<br>

## ğŸ’¡ Type Definition

OCaml ì—ì„œëŠ” ì‚¬ìš©ìê°€ ìƒˆë¡œìš´ íƒ€ì…ì„ ì •ì˜í•  ìˆ˜ ìˆë‹¤. <br>

`type [type_name] = [type]` ì˜ í˜•íƒœë¡œ ì‚¬ìš©í•˜ë©°, <br>

C/C++ì˜ `typedef`ì™€ ìœ ì‚¬í•˜ë‹¤. <br>

ì¼ë°˜ì ìœ¼ë¡œ OCamlì€ ê°•ë ¥í•œ íƒ€ì… ì¶”ë¡  ê¸°ëŠ¥ì„ ê°€ì§€ê³  ìˆì–´, íƒ€ì…ì„ ëª…ì‹œì ìœ¼ë¡œ <br>

ì§€ì •í•´ì¤„ í•„ìš”ê°€ ì—†ëŠ” ê²½ìš°ê°€ ë§ì§€ë§Œ, ìƒˆë¡œìš´ íƒ€ì…ì„ ì •ì˜í•œ ê²½ìš°, ì½”ë“œì˜ ê°€ë…ì„±ì„ <br>

ë†’ì´ê³ , ì˜ë„ë¥¼ ëª…í™•í•˜ê²Œ ì „ë‹¬í•˜ê¸° ìœ„í•´ ëª…ì‹œì ìœ¼ë¡œ íƒ€ì…ì„ ì§€ì •í•´ì£¼ëŠ” ê²ƒì´ ì¢‹ë‹¤. <br>

```ml
type INT = int

let add_two_integers (x : INT) (y : INT) : INT = x + y

let x : INT = 10
let y : INT = 20

let sum : INT = add_two_integers x y

Format.printf "sum : %d\n" sum
```

<br>

- **Disjoint union**

    + OCamlì—ì„œ `Disjoint union`ì´ë€ ì—¬ëŸ¬ ê°œì˜ ë‹¤ë¥¸ íƒ€ì…ì„ í•˜ë‚˜ì˜ íƒ€ì…ìœ¼ë¡œ ë¬¶ëŠ” ë° <br>

      ì‚¬ìš©ë˜ëŠ” ê°œë…ì´ë‹¤. ì´ë¥¼ í†µí•´ í•˜ë‚˜ì˜ ê°’ì´ ì—¬ëŸ¬ ë‹¤ë¥¸ í˜•ì‹ì„ ê°€ì§ˆ ìˆ˜ ìˆìœ¼ë©°, <br>

      `Variant records` ë¼ê³ ë„ ë¶€ë¥¸ë‹¤. <br>

    + `type` í‚¤ì›Œë“œì™€ `|` ë¥¼ ì‚¬ìš©í•˜ì—¬ ì •ì˜í•œë‹¤. <br>

    + ì•„ë˜ ì½”ë“œì—ì„œ `Circle`, `Rectangle` ê³¼ ê°™ì€ ì‹ë³„ìëŠ” `ëŒ€ë¬¸ìë¡œ ì‹œì‘í•´ì•¼`í•˜ë©°, <br>

      `Constructor` ë¼ê³  ë¶ˆë¦°ë‹¤.

    ```ml
    type shape =
      | Circle of float
      | Rectangle of float * float

    let cal_area = function
      | Circle r -> 3.14 *. r *. r
      | Rectangle (w, h) -> w *. h

    let circle_area = calculate_area (Circle 2.0)
    let rectangle_area = calculate_area (Rectangle (3.0, 4.0))
    ```
