---
title: "[OS] Interrupt"
excerpt: "Operating Systems, Internals and Design Principles 정리"

categories:
  - CS
tags:
  - [Operating System]

permalink: /cs/operating_system11/

toc: true
toc_sticky: true
use_math: true

date: 2024-06-06
last_modified_at: 2025-05-05
published: true
---

# 👑 Interrupt

`인터럽트 (Interrupt)`는 하드웨어 또는 소프트웨어 이벤트가 발생할 때 CPU의 현재 작업을 중단하고 <br>

즉시 그 이벤트를 처리하기 위한 메커니즘이다. 이는 주로 I/O 장치나 타이머 등의 요청을 처리하기 위해 <br>

사용된다. 한 가지 예로, 시분할 시스템에서는 `time slice`가 끝날 때 마다 `Timer Interrupt`를 <br>

발생시켜 현재 프로세스의 작업을 중지시키고, 스케줄링을 실행시켰다. <br>

<br>

## 💡 종류

- **하드웨어 인터럽트 (Hardware Interrupt)**

    + 외부 장치(예: 키보드, 마우스)에서 발생하며, 하드웨어 신호를 통해 CPU에 인터럽트를 요청한다.

<br>

- **소프트웨어 인터럽트(Software Interrupt) == 트랩 (Trap)**

    + 소프트웨어에서 발생하며, 주로 예외 상황(예: 0으로 나누기)이나 시스템 호출을 위해 사용된다.

<br>

## 💡 주요 특성

- **비동기(Asynchronous) 이벤트 처리**

    + 인터럽트는 비동기적으로 발생한다.
    
    + 즉, 현재 실행 중인 프로그램의 흐름과 관계없이 언제든지 발생할 수 있다.

<br>

- **중첩 처리(Nested Processing)**

    + 인터럽트는 중첩되어 발생할 수 있다.
    
    + 즉, 하나의 인터럽트가 처리되는 도중에 또 다른 인터럽트가 발생할 수 있다.

    + 이러한 상황에서 시스템은 우선 순위에 따라 인터럽트를 처리한다.
    
    + 예를 들어, 높은 우선 순위의 인터럽트가 낮은 우선 순위의 인터럽트보다 먼저 처리된다.

<br>

## 💡 동작 방식

<center><img src="https://github.com/jinwoojwa/jinwoo.github.io/assets/112393728/b600e11b-5ea4-49a6-b69e-bc20dbfb9575"></center>

- **인터럽트 발생**

    + 주변 장치에서 이벤트가 발생하면, 해당 장치는 CPU에 인터럽트 신호를 보낸다.

    + `User mode`에서 `Kernel mode`로 `mode change`가 발생한다.

    <br>

        사용자 모드(User Mode) : 프로그램이 일반적인 응용 프로그램 코드로 실행되는 모드이다.
        커널 모드(Kernel Mode) : 운영체제의 핵심 기능을 수행하기 위한 모드로,
                                하드웨어 자원에 대한 완전한 접근 권한을 가진다.

<br>

- **현재 작업 중단 및 Context 저장**

    + CPU는 현재 실행 중인 명령어를 완료하고, 인터럽트를 받아들인다.

    + 현재 작업의 상태(PC, 레지스터 값 등)를 저장하여 나중에 작업을 재개할 수 있도록 한다.

<br>

- **인터럽트 벡터를 통해 핸들러 호출**

    + CPU는 `IVT`을 참조하여, 해당 `ISR(=인터럽트 핸들러)`을 찾는다.

    + `ISR(= 인터럽트 핸들러)`는 인터럽트 요청을 처리하는 코드를 포함하고 있다.

    + `IDT(Interrupt Descriptor Table) = IVT (Interrupt Vector Table)`

    + `IVT` : 각 인터럽트 번호에 대응하는 `ISR(Interrupt Service Routine)` 주소를 갖는 테이블

<br>

- **인터럽트 처리**

    + `ISR`은 인터럽트 서비스 작업의 최소한의 긴급한 부분을 수행한다.
    
    + 예를 들어, 데이터 수신이나 장치 상태 확인 등 즉각적인 처리가 필요한 작업을 수행한다.
    
    + `ISR`은 또한 나중에 처리할 필요가 있는 나머지 작업(bottom half)을 표시(mark)한다.
    
    + 이 작업은 인터럽트 처리의 하단부로, 덜 긴급한 작업을 의미한다.

<br>

- **새로운 인터럽트가 발생하면 반복**

    + ISR 실행 중에 새로운 인터럽트가 발생하면, 커널은 위 단계를 반복하여 새로운 <br>
      인터럽트를 처리한다

<br>

- **ISR 완료 후 특별 코드 블록 실행**

    + ISR 및 다른 모든 중첩된 ISR이 완료되면, 커널은 `Special code block`을 실행한다.
    
    + 이 코드 블록은 다음 작업을 수행한다.

        * 모든 표시된(bottom halves) 인터럽트 처리의 하단부를 실행한다.
        * 완료된 프로세스를 준비 상태로 설정한다.
        * 스케줄러를 호출한다.

<br>

- **스케줄러가 적절한 작업 선택**

    + 스케줄러에 의해 다음 작업이 선택된다.

        * 인터럽트된 작업이 다시 선택될 경우 : 저장된 `context`를 복원하고 인터럽트된 작업을 재개
        * 그 외의 경우 : `문맥 전환(Context Switch)`을 수행하여 다른 작업을 실행

<br>

### 🚩 To Do After System Call/Interrupt

시스템 호출이나 인터럽트가 발생한 후, 운영체제는 여러 작업을 수행해야 한다. <br>

Linux 운영체제는 시스템 호출이나 인터럽트가 완료된 후에 실행되는 `Special code block`을 가지고 있다. <br>
    
이 코드 블록은 남은 작업을 완료하고 시스템 상태를 점검하는 역할을 한다. <br><br>

- **남은 인터럽트 서비스 루틴 수행**

    + 인터럽트 처리의 상단부에서 즉시 처리되지 않은 작업(하단부 작업)이 남아 있을 수 있다.
    
    + 이 작업들은 후속 처리로 예약되어 있고, 이 특별 코드 블록에서 수행된다.

- **처리해야 할 Signal 확인**

    + 프로세스에 대기 중인 `Signal`이 있는지 확인하고, 있으면 처리한다.

- **스케줄러 호출 필요 여부 확인**

- **스케줄러 호출 및 프로세스 전환**

    + 스케줄러가 호출되면, 현재 프로세스를 준비 상태(Ready state)로 전환하고, <br>
      다음 실행할 프로세스를 선택하여 활성화한다.

    + 이 과정은 `문맥 전환(Context Switch)을 포함`한다. 즉, CPU는 현재 프로세스의 상태를 <br>
      저장하고, 선택된 새로운 프로세스의 상태를 복원하여 실행을 시작한다.

<br>

## 💡 예시

**키보드를 사용자가 눌렀을 때**

1. 키보드를 누르면 키보드 장치는 인터럽트를 발생시켜 CPU에 알린다.

2. CPU는 현재 작업을 중단하고, 키보드 인터럽트를 처리하는 핸들러를 호출한다.

3. 인터럽트 핸들러는 키보드 입력을 읽어와 메모리에 저장하거나, 해당 입력을 처리한다.

4. 인터럽트 처리가 완료되면 CPU는 원래의 작업을 재개한다.

<br>

**Time Slice**

운영체제는 주기적으로 `time slice`를 설정하여 특정 시간 간격마다 `timer interrupt`가 <br>

발생하도록 한다. 이 인터럽트는 프로세스 스케줄링과 같은 주기적인 작업을 수행하는 데 사용된다.

<br>

# 👑 Trap

`트랩 (Trap)`이란 `CPU`에 의해 발생하는 `인터럽트 (Interrupt)`이다. <br>

주로 `비동기 (Asynchronous)` 소프트웨어적인 이벤트로 인해 발생하며, 커널은 트랩을 <br>

인터럽트와 같은 방식으로 처리한다.
